"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateLastLogin = exports.updateUser = exports.getUserByEmail = exports.getUserById = exports.createUser = void 0;
const CosmosService_1 = require("@src/services/azure/CosmosService");
const jet_logger_1 = __importDefault(require("jet-logger"));
const CONTAINER_NAMES = {
    USERS: 'Users',
    FILES: 'Files',
    SHARE_LINKS: 'ShareLinks',
};
/**
 * Create a new user
 */
const createUser = async (user) => {
    try {
        const container = await (0, CosmosService_1.getContainer)(CONTAINER_NAMES.USERS, '/userId');
        const { resource } = await container.items.create(user);
        if (!resource) {
            throw new Error('Failed to create user');
        }
        return resource;
    }
    catch (error) {
        if (error.code === 409) {
            throw new Error('User with this email already exists');
        }
        jet_logger_1.default.err(error);
        throw new Error('Failed to create user');
    }
};
exports.createUser = createUser;
/**
 * Get user by userId
 */
const getUserById = async (userId) => {
    try {
        const container = await (0, CosmosService_1.getContainer)(CONTAINER_NAMES.USERS, '/userId');
        // Query by userId (partition key) instead of using item(id, partitionKey)
        // because Cosmos DB auto-generates an 'id' field that differs from userId
        const querySpec = {
            query: 'SELECT * FROM c WHERE c.userId = @userId',
            parameters: [
                {
                    name: '@userId',
                    value: userId,
                },
            ],
        };
        const { resources } = await container.items.query(querySpec).fetchAll();
        return resources.length > 0 ? resources[0] : null;
    }
    catch (error) {
        if (error.code === 404) {
            return null;
        }
        jet_logger_1.default.err(error);
        throw new Error('Failed to get user');
    }
};
exports.getUserById = getUserById;
/**
 * Get user by email
 */
const getUserByEmail = async (email) => {
    try {
        const container = await (0, CosmosService_1.getContainer)(CONTAINER_NAMES.USERS, '/userId');
        const querySpec = {
            query: 'SELECT * FROM c WHERE c.email = @email',
            parameters: [
                {
                    name: '@email',
                    value: email,
                },
            ],
        };
        const { resources } = await container.items
            .query(querySpec)
            .fetchAll();
        return resources.length > 0 ? resources[0] : null;
    }
    catch (error) {
        // If it's a 404 or not found error, return null (user doesn't exist)
        if (error.code === 404) {
            return null;
        }
        // Log the error but don't throw - allow caller to handle
        jet_logger_1.default.err('Error getting user by email:', error);
        // Return null instead of throwing - this allows registration to proceed
        // if the check fails due to connection issues
        return null;
    }
};
exports.getUserByEmail = getUserByEmail;
/**
 * Update user
 */
const updateUser = async (user) => {
    try {
        const container = await (0, CosmosService_1.getContainer)(CONTAINER_NAMES.USERS, '/userId');
        // First, get the user to find the Cosmos DB 'id' field
        const existingUser = await (0, exports.getUserById)(user.userId);
        if (!existingUser) {
            throw new Error('User not found');
        }
        // Use the Cosmos DB 'id' field for the replace operation
        // The 'id' field is auto-generated by Cosmos DB and is different from userId
        const cosmosId = existingUser.id || user.userId;
        const { resource } = await container
            .item(cosmosId, user.userId)
            .replace(user);
        if (!resource) {
            throw new Error('Failed to update user');
        }
        return resource;
    }
    catch (error) {
        jet_logger_1.default.err(error);
        throw new Error('Failed to update user');
    }
};
exports.updateUser = updateUser;
/**
 * Update last login timestamp
 */
const updateLastLogin = async (userId) => {
    try {
        const user = await (0, exports.getUserById)(userId);
        if (!user) {
            throw new Error('User not found');
        }
        user.lastLogin = new Date();
        await (0, exports.updateUser)(user);
    }
    catch (error) {
        jet_logger_1.default.err(error);
        throw new Error('Failed to update last login');
    }
};
exports.updateLastLogin = updateLastLogin;
/******************************************************************************
                            Export default
******************************************************************************/
exports.default = {
    createUser: exports.createUser,
    getUserById: exports.getUserById,
    getUserByEmail: exports.getUserByEmail,
    updateUser: exports.updateUser,
    updateLastLogin: exports.updateLastLogin,
};
